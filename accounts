// features/accounts/users/components/UsersDirectory.tsx
import { useMemo, useState } from "react";
import {
  Card,
  CardHeader,
  CardTitle,
  CardDescription,
  CardContent,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Search, Edit3, Eye } from "lucide-react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { useNavigate } from "react-router-dom";
import { usePagination } from "@/hooks/usePagination";
import { PaginationControls } from "@/components/ui/pagination-controls";

type Role =
  | "Domain Admin"
  | "Project Admin"
  | "Review Manager"
  | "Reviewer"
  | "User";
type Status = "Active" | "Inactive";

type User = {
  name: string;
  email: string;
  role: Role;
  status: Status;
};

// Dummy directory
const DIRECTORY: User[] = [
  {
    name: "Alice Johnson",
    email: "alice.johnson@aurora.com",
    role: "Domain Admin",
    status: "Active",
  },
  {
    name: "Brian Lee",
    email: "brian.lee@aurora.com",
    role: "Project Admin",
    status: "Active",
  },
  {
    name: "Catherine Smith",
    email: "catherine.smith@aurora.com",
    role: "Reviewer",
    status: "Inactive",
  },
  {
    name: "Daniel Roberts",
    email: "daniel.roberts@aurora.com",
    role: "User",
    status: "Active",
  },
  {
    name: "Emily Clark",
    email: "emily.clark@aurora.com",
    role: "Review Manager",
    status: "Active",
  },
];

type UsersDirectoryProps = {
  onEditUser: (user: User) => void;
};

export function UsersDirectory({ onEditUser }: UsersDirectoryProps) {
  const navigate = useNavigate();
  const [searchQuery, setSearchQuery] = useState("");

  const suggestions = useMemo(
    () =>
      DIRECTORY.filter(
        (u) =>
          u.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
          u.email.toLowerCase().includes(searchQuery.toLowerCase()) ||
          u.role.toLowerCase().includes(searchQuery.toLowerCase()) ||
          u.status.toLowerCase().includes(searchQuery.toLowerCase())
      ),
    [searchQuery]
  );

  const {
    currentPage,
    pageSize,
    totalPages,
    paginatedData: paginatedUsers,
    setCurrentPage,
    setPageSize,
  } = usePagination({ data: suggestions, initialPageSize: 10 });

  return (
    <Card>
      <CardHeader>
        <CardTitle>Users</CardTitle>
        <CardDescription>Manage user access and permissions</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="relative mb-4">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search by name, email, role, or status..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-10"
          />
        </div>

        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Name</TableHead>
              <TableHead>Email</TableHead>
              <TableHead>Role</TableHead>
              <TableHead>Status</TableHead>
              <TableHead className="text-right">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {paginatedUsers.map((u) => (
              <TableRow key={u.email}>
                <TableCell className="font-medium">{u.name}</TableCell>
                <TableCell>{u.email}</TableCell>
                <TableCell>{u.role}</TableCell>
                <TableCell>
                  <span
                    className={`inline-flex items-center px-2 py-1 rounded-md text-xs font-medium ${
                      u.status === "Active"
                        ? "bg-green-50 text-green-700 dark:bg-green-950 dark:text-green-300"
                        : "bg-gray-50 text-gray-700 dark:bg-gray-950 dark:text-gray-300"
                    }`}
                  >
                    {u.status}
                  </span>
                </TableCell>
                <TableCell className="text-right">
                  <div className="flex justify-end gap-2">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => onEditUser(u)}
                    >
                      <Edit3 className="h-3 w-3 mr-1" />
                      Edit
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() =>
                        navigate(
                          `/accounts/users?email=${encodeURIComponent(
                            u.email
                          )}`
                        )
                      }
                    >
                      <Eye className="h-3 w-3 mr-1" />
                      View
                    </Button>
                  </div>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>

        <PaginationControls
          currentPage={currentPage}
          totalPages={totalPages}
          pageSize={pageSize}
          totalItems={suggestions.length}
          onPageChange={setCurrentPage}
          onPageSizeChange={setPageSize}
        />

        {suggestions.length === 0 && searchQuery && (
          <p className="text-sm text-muted-foreground text-center py-6">
            No users found.
          </p>
        )}
      </CardContent>
    </Card>
  );
}

export type { User };


// features/accounts/users/components/UserInfo.tsx
import { useSearchParams, useNavigate } from "react-router-dom";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { ArrowLeft, Mail, Shield, Clock, CheckCircle2 } from "lucide-react";

export function UserInfo() {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const email = searchParams.get("email");

  // Mock user data - replace with actual data fetching
  const user = {
    name: "Alice Johnson",
    email: email || "alice.johnson@aurora.com",
    role: "Domain Admin",
    status: "Active",
    joinedDate: "January 15, 2024",
    lastActive: "2 hours ago",
    manager: "John Doe",
    department: "Engineering",
    projects: ["Project Alpha", "Project Beta", "Project Gamma"],
  };

  return (
    <div className="space-y-6">
      {/* Header with Back Button */}
      <div className="flex items-center gap-4">
        <Button
          variant="outline"
          size="sm"
          onClick={() => navigate("/accounts/users")}
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Users
        </Button>
      </div>

      {/* User Profile Card */}
      <Card>
        <CardHeader>
          <div className="flex items-start justify-between">
            <div>
              <CardTitle className="text-2xl">{user.name}</CardTitle>
              <CardDescription className="flex items-center gap-2 mt-2">
                <Mail className="h-4 w-4" />
                {user.email}
              </CardDescription>
            </div>
            <div className="flex items-center gap-2">
              <span
                className={`inline-flex items-center px-3 py-1 rounded-md text-sm font-medium ${
                  user.status === "Active"
                    ? "bg-green-50 text-green-700 dark:bg-green-950 dark:text-green-300"
                    : "bg-gray-50 text-gray-700 dark:bg-gray-950 dark:text-gray-300"
                }`}
              >
                <CheckCircle2 className="h-3 w-3 mr-1" />
                {user.status}
              </span>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <div className="grid gap-6 md:grid-cols-2">
            {/* Left Column */}
            <div className="space-y-4">
              <div>
                <div className="text-sm font-medium text-muted-foreground mb-1">
                  Role
                </div>
                <div className="flex items-center gap-2">
                  <Shield className="h-4 w-4 text-primary" />
                  <span className="font-medium">{user.role}</span>
                </div>
              </div>

              <div>
                <div className="text-sm font-medium text-muted-foreground mb-1">
                  Department
                </div>
                <div className="font-medium">{user.department}</div>
              </div>

              <div>
                <div className="text-sm font-medium text-muted-foreground mb-1">
                  Reporting Manager
                </div>
                <div className="font-medium">{user.manager}</div>
              </div>
            </div>

            {/* Right Column */}
            <div className="space-y-4">
              <div>
                <div className="text-sm font-medium text-muted-foreground mb-1">
                  Joined Date
                </div>
                <div className="font-medium">{user.joinedDate}</div>
              </div>

              <div>
                <div className="text-sm font-medium text-muted-foreground mb-1">
                  Last Active
                </div>
                <div className="flex items-center gap-2">
                  <Clock className="h-4 w-4 text-muted-foreground" />
                  <span className="font-medium">{user.lastActive}</span>
                </div>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Projects Card */}
      <Card>
        <CardHeader>
          <CardTitle>Assigned Projects</CardTitle>
          <CardDescription>
            Projects this user has access to
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-2">
            {user.projects.map((project) => (
              <div
                key={project}
                className="flex items-center justify-between p-3 rounded-lg border"
              >
                <span className="font-medium">{project}</span>
                <Button variant="outline" size="sm">
                  View Details
                </Button>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}


// features/accounts/users/pages/Users.tsx
import { useState } from "react";
import { useSearchParams } from "react-router-dom";
import { Dashboard } from "../components/Dashboard";
import { UsersDirectory } from "../components/UsersDirectory";
import { AddUserDialog } from "../components/AddUserDialog";
import { EditUserDialog } from "../components/EditUserDialog";
import { UserInfo } from "../components/UserInfo";
import type { User } from "../components/UsersDirectory";

export default function Users() {
  const [searchParams] = useSearchParams();
  const email = searchParams.get("email");

  const [editOpen, setEditOpen] = useState(false);
  const [selectedUser, setSelectedUser] = useState<User | null>(null);

  const handleEditUser = (user: User) => {
    setSelectedUser(user);
    setEditOpen(true);
  };

  // If email param exists, show user info view
  if (email) {
    return <UserInfo />;
  }

  // Otherwise show accounts list view
  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Accounts</h1>
          <p className="text-muted-foreground mt-1">
            Manage user access and permissions
          </p>
        </div>

        <div className="flex gap-2">
          <AddUserDialog />
        </div>
      </div>

      {/* Dashboard - Role Stats */}
      <Dashboard />

      {/* Users Directory */}
      <UsersDirectory onEditUser={handleEditUser} />

      {/* Edit User Dialog */}
      <EditUserDialog
        open={editOpen}
        onOpenChange={setEditOpen}
        user={selectedUser}
      />
    </div>
  );
}


here are the two files Users.tsx and UsersDirectory.tsx, in which the list of user are in hardcoded data // Dummy directory but we want to get the data from the api 

i want you to write the code in a way that i can take the data from api like dummy directory for representing in the list so i want you to refactor the code
and write the backend asp.net and identity framework for backend in layers so that i can get the all the users and show in the table make sure to keep things clear
for now we want getUser() this will get the all user in the   api that return all the users with data 
and the data is and you can you one dto for returning this data for this api or whatever is the best practice
user {
    name: "",
    email: "",
    role: "",
    status: "",
  },


using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;

namespace Authentication.Service.Repository
{
    public class ApplicationDbContext : IdentityDbContext<ApplicationUser>
    {
        public DbSet<RefreshTokenStore> RefreshTokensStore { get; set; }
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options) { }

        protected override void OnModelCreating(ModelBuilder builder)
        {
            base.OnModelCreating(builder);

            // Here you can configure table names, relationships, etc.
            // Example:
            // builder.Entity<ApplicationUser>().ToTable("Users");
        }

    }
}

using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;

namespace Authentication.Service.Repository
{
  
        public class ApplicationDbContextFactory : IDesignTimeDbContextFactory<ApplicationDbContext>
        {
            public ApplicationDbContext CreateDbContext(string[] args)
            {
                var optionsBuilder = new DbContextOptionsBuilder<ApplicationDbContext>();

                optionsBuilder.UseSqlServer(
                    "Data Source=.\\SQLEXPRESS;Initial Catalog=AuthDb;User ID=sa;Password=Consilio@@112233;TrustServerCertificate=True;Pooling=True;"
                );

                return new ApplicationDbContext(optionsBuilder.Options);
            }
        }
    }




using Authentication.Service.Application;
using Microsoft.AspNetCore.Mvc;
using Authentication.Service.Common.DTOs;

namespace Authentication.Service.Controller.Controllers
{
 
    // AuthService.API/Controllers/AuthController.cs
    using Authentication.Service.Common.DTOs;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Identity.Client;

    [ApiController]
    [Route("api/[controller]")]
    public class AuthController : ControllerBase
    {
        private readonly IAuthService _authService;

        public AuthController(IAuthService authService) => _authService = authService;

        [HttpPost("register")]
        public async Task<IActionResult> Register(UserRegisterDto dto)
        {
            var response = await _authService.RegisterAsync(dto);
            return Ok(response);
        }

        [HttpPost("login")]
        public async Task<IActionResult> Login(UserLoginDto dto)
        {
            var response = await _authService.LoginAsync(dto);
            return Ok(response);
        }

        [HttpPost("refreshtoken")]
        public async Task<IActionResult> RefreshToken(string refreshToken)
        {
            var accessToken=await _authService.RefreshToken(refreshToken);
            return Ok(accessToken);
        }
    }

}
using Authentication.Service.Business;
using Authentication.Service.Common;
using Authentication.Service.Common.DTOs;
using Authentication.Service.Common.utils;
using Authentication.Service.Repository;
using Microsoft.AspNetCore.Identity;
using Microsoft.Extensions.Configuration;
using Microsoft.Identity.Client;
using Microsoft.IdentityModel.Tokens;
using System;
using System.Collections.Generic;
using System.IdentityModel.Tokens.Jwt;
using System.Linq;
using System.Security.Claims;
using System.Security.Cryptography.Xml;
using System.Text;
using System.Threading.Tasks;


namespace Authentication.Service.Application
{
    public class AuthService : IAuthService
    {
        private readonly IUserRepository _userRepository;
        private readonly IConfiguration _configuration;
        private readonly ITokenService _tokenService;
        private readonly IRefreshTokenRepository _refreshTokenRepository;

        public AuthService(IUserRepository userRepository, IRefreshTokenRepository refreshTokenRepository, IConfiguration configuration, ITokenService tokenService)
        {
            _userRepository = userRepository;
            _configuration = configuration;
            _tokenService = tokenService;
            _refreshTokenRepository = refreshTokenRepository;
        }

        public async Task<RegisterResponseDto> RegisterAsync(UserRegisterDto dto)
        {

            var user = await _userRepository.GetUserByEmailAsync(dto.Email);
            if (user != null)
            {
                throw new AccountAlreadyExistsException("User Already Exists in the database");
            }
            var result = await _userRepository.RegisterAsync(dto);
            if (!result.Succeeded)
            {
                var errors = string.Join("; ", result.Errors.Select(e => e.Description));
                throw new Exception($"User registration failed: {errors}");
            }

            return new RegisterResponseDto() { UserName = dto.UserName, Email = dto.Email, Role = dto.Role };
        }

        public async Task<AuthResponseDto> LoginAsync(UserLoginDto dto)
        {
            var user = await _userRepository.GetUserByEmailAsync(dto.Email);
            if (user == null || !await _userRepository.CheckPasswordAsync(user, dto.Password))
                throw new Exception("Invalid credentials");

            var roles = await _userRepository.GetUserRolesAsync(user);
            var accessToken = _tokenService.GenerateAccessToken(dto, roles);
            var refreshToken = _tokenService.GenerateRefreshToken();

            var refreshTokenInfo = new RefreshTokenStore()
            {
                Token = refreshToken,
                UserEmail = user.Email,
                ExpiresAt = DateTime.Now.AddDays(7),

            };

            _refreshTokenRepository.AddNewRefreshToken(refreshTokenInfo);
            return new AuthResponseDto { AccessToken = accessToken, RefreshToken = refreshToken, UserName = user.UserName, Email = user.Email };
        }

        public async Task<AuthResponseDto> RefreshToken(string refreshToken)
        {
            try
            {
                // Validate the refresh token’s existence
                var storedToken = await _refreshTokenRepository.FindTokenAsync(refreshToken);
                if (storedToken == null)
                    throw new RefreshTokenDoesNotExistsException("Refresh token does not exists");

                //Check token expiration
                if (storedToken.ExpiresAt < DateTime.Now)
                    throw new RefreshTokenExpiredException("Refresh token expired");

                // Check if it’s revoked or replaced
                if (storedToken.IsRevoked)
                    throw new RefreshTokenAlreadyRevokedException("Refresh token already revoked");

                // Verify the user still exists and is active
                var user = await _userRepository.GetUserByEmailAsync(storedToken.UserEmail);
                if (!user.IsActive)
                    throw new InactiveUserException("User is inactive");

                // Generate a new access token by fetching the user information
                var roles = await _userRepository.GetUserRolesAsync(user);
                var newAccessToken = _tokenService.GenerateAccessToken(new UserLoginDto() { Email = user.Email }, roles);

                // Generate a new refresh token (rotation)
                var newRefershToken = _tokenService.GenerateRefreshToken();


                // revoke the peviously created refresh token 
                storedToken.IsRevoked = true;

                // Generate the new refresh Token
                var refreshTokenInfo = new RefreshTokenStore()
                {
                    Token = newRefershToken,
                    UserEmail = user.Email,
                    ExpiresAt = DateTime.Now.AddDays(7),
                    RevokedByToken = refreshToken

                };


                _refreshTokenRepository.AddNewRefreshToken(refreshTokenInfo);

                return new AuthResponseDto()
                {
                    AccessToken = newAccessToken,
                    RefreshToken = newRefershToken,
                    UserName = user.UserName,
                    Email = user.Email
                };

            }
            catch (Exception ex) when (ex is RefreshTokenAlreadyRevokedException ||
                                       ex is RefreshTokenDoesNotExistsException ||
                                       ex is RefreshTokenExpiredException ||
                                       ex is InactiveUserException)
            {
                throw ex;
            }

        }
    }
}
using Authentication.Service.Common.DTOs;
using Microsoft.AspNetCore.Identity;


namespace Authentication.Service.Repository
{
    public class UserRepository:IUserRepository
    {
        private readonly UserManager<ApplicationUser> _userManager;

        public UserRepository(UserManager<ApplicationUser> userManager)
        {
            _userManager = userManager;
        }

        public async Task<IdentityResult> RegisterAsync(UserRegisterDto dto)
        {
            var user = new ApplicationUser { UserName = dto.UserName, Email = dto.Email,IsActive=true };
            var result = await _userManager.CreateAsync(user, dto.Password);

            if (result.Succeeded)
            {
                // Assign role (make sure role exists)
                await _userManager.AddToRoleAsync(user, dto.Role);
            }

            return result;
        }

        public async Task<IList<string>> GetUserRolesAsync(ApplicationUser user)
        {
            var applicationUser = new ApplicationUser();
            return await _userManager.GetRolesAsync(user);
        }

        public async Task AssignRoleAsync(ApplicationUser user, string role)
        {
            if (!await _userManager.IsInRoleAsync(user, role))
            {
                await _userManager.AddToRoleAsync(user, role);
            }
        }

        public async Task<ApplicationUser> GetUserByEmailAsync(string email)
            => await _userManager.FindByEmailAsync(email);

        public async Task<bool> CheckPasswordAsync(ApplicationUser user, string password)
            => await _userManager.CheckPasswordAsync(user, password);


    }
}
